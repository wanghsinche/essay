> 996只会阻碍进步的脚步

现在天天在家办公，个人时间一大把。碰巧github推出的人工智能助手（copilot）在代码补全领域里大杀特杀，让我又有了一些失业的焦虑感，觉得很有必要拿起来机器学习书籍好好入门。

得益于这些年机器学习的普及，这次重新入门机器学习，相比之前前第一次接触，有了质的飞跃，总算摸到了边：主要感谢一本业内人士看不上的小书----《 从零开始：机器学习的数学原理和算法实践 》还有伦敦帝国学院的数学课程，让我终于补齐了对微分，线性代数，和概率论的直观理解。还有是《neural networks and deep learning》，真正把我带入了深度学习的世界。

在这我直接给出我总结的“deep learning入门流程”。

在这假设数学能力只有大二水平，并且已经忘掉了大半。    

一、 
首先回忆高中学到的线性回归。    

给一堆数据点X，对应的值Y，让你用多项式拟合出一个X到Y的映射。在这里，把这个多项式称为模型。将多项式输出结果和真实结果之间的差别称为损失函数。那么好的模型就是使这个损失函数最小的模型。

机器学习的目的就是寻找这个最优模型。    

找出令损失函数最小化的模型实际上是一个最优化问题，“梯度下降法”是这类问题的一个通用解法。 

于是经过一系列迭代，解出一个多项式。机器学习里面把这过程称为“学习”或者说“训练”。然而解出的多项式模型很容易过于复杂，也就是，阶数太高了。这会导致“过拟合”，对于没见过的数据拟合精度大幅下降。   

为了解决过拟合，数学家引入“正则化”方法----在损失函数加多一项，用于惩罚阶数过高的模型。这样子就会倾向于迭代出更简单的多项式模型。而经验表明，这些阶数更低，更简单的多项式模型的确“泛化能力”更强，不容易过拟合。    

然而这只是一种玄学，没人能肯定说简单的模型一定更好，只能说经验使然。正则化为什么可以提高泛化能力还有很多种解释，有兴趣自己再看。    

根据正则化加入的“惩罚项”不同，又能分出不同的模型。人们把最常用的两种起名：ridge regression 和 lasso regression。为了让线性回归可以用于分类，人们又在多项式外面套多一层logistic 函数，将值域压缩到0，1。这样子就被叫做logistic 回归。    

至此，机器学习大门的第一把钥匙已经到手。   

二、  
由此可见机器学习更多的是数学而非计算机。有必要把数学短板补齐。用到的知识也不多，微分，线性代数，概率论，一点点信息论。    

微分部分很重要但很简单：偏微分，泰勒展开，梯度，链式法则。没了。    

概率论不需要知道很多：原理性的大数定律和中心极限定理知道就好。而贝叶斯那个公式其实就是在求“某事件”在“某个前提下”出现的概率。    

信息论也都是很浅显直白的定义。入门时知道信息熵，信息增益就可以了。    

三、  
比较玄学的是线性代数。我学完之后直到最近才开始建立起直观的感受。

这里推荐伦敦帝国学院的《Mathematics for Machine Learning Specialization》，线性代数那课就两小时。    

从几何的角度理解线性代数，矩阵其实是空间变换。为了简化，我只讨论方阵。    

回忆一下高中解析几何，先找一个笛卡尔二维空间，也就是一个x轴一个y轴垂直相交。把里面的entity都用向量来表示。比如一个原点到（1，1）点的箭头就是向量[1,1]。那么向量乘以矩阵就是对这个二维空间做线性变换。如果乘以一个[[2,0],[0,2]]，那就是这个空间被缩放了两倍。旋转也是类似道理。   

人们观察到经过线性变换后，有些向量的方向不会改变。这代表了这个线性变换中某种“永恒不变”“形而上学”的本质。这些向量就是----特征向量。    

这些特征向量虽然方向不变，但是长度还是会被改变。这里的改变程度就是----特征值。显而易见的，把所有特征值乘起来，就是原来空间里的entity经过这次线性变换后，“体积”的变化率。很巧合的是，这刚好就是矩阵的“行列式”的值。    

矩阵的乘法相当诡异。

从线性变换的角度看，两个矩阵相乘就是两种线性变换的合变换。既然可以合并变换，也就可以拆分变换。为了简化矩阵乘法计算，人们利用空间变换里的“永恒不变”性质--特征值和特征向量，搞出来“特征分解”。分解之后再去对向量做空间变换，计算难度就小了许多。    

然而不是任何矩阵都能特征分解，所以人们想到把矩阵当作空间变换来看。把复杂的空间变换分解为几个简单的缩放，旋转之类的空间变换。这样子就是所谓的奇异值分解。    

建立起这些直观概念之后，再回头看《线性代数》，会觉得书中很多定理简直是不言而喻的“废话”。比如相似矩阵特征值相同。比如正定矩阵的行列式大于零。爸爸的爸爸肯定叫爷爷啊。。。   

拿到机器学习的第二把钥匙！    

四、
补齐以上数学知识后再随便找一本机器学习的书（千万不要是那边周志华的西瓜书，误人子弟罢了），看贝叶斯分类，决策树，随机森林会非常简单。分分钟可以用python写出这些模型。 而这些模型scikit-learn已经帮我们写好，实际使用只要会调用，知道参数意义即可。  

学到这里机器学习其实已经入门了。传统的模型处理分类任务简单又好用。    

在此我特意跳过了大名鼎鼎的支持向量机，SVM。在我看来这东西数学技巧性太高，没有通用解法，对于业余选手意义不大。    

打个比方，我要的是多元一次方程组的无脑解法，而不是神秘兮兮的龟兔同笼中国式智慧。    

五、
最后，终于来到了deep learning的大门口，直接上手编写最基础的前馈神经网络。

神经网络模型的训练类似线性回归模型：拿到损失函数，梯度下降，迭代，出结果。deep的意思是深层，也就是模型里有很多层神经网络。    

然而多层神经网络的问题是用梯度下降法迭代时，梯度太难求了。直到上世纪八十年代，在大名鼎鼎的Hinton大佬加持下，Backpropagation（反向传播算法）才正式在神经网络领域确立了地位。    所以反向传播算法本质就是针对神经网络模型梯度计算的一种高效算法。如果各位微分学的很好，也许自己独立推导出来也不是不可能。    

弄懂了反向传播算法，写一个前馈神经网络程序也是分分钟的事。然后你就可以拿著名的手写数字数据集来训练和识别了。这里我推荐的书是Michael Nielsen写的《neural networks and deep learning》。一定不要看哈工大那个翻译版，说实在翻译水平还不如谷歌的人工智能。    

哎，只能说相见恨晚，它这书18年才有在线免费版，我走了太多弯路。看完这本书如果还意犹未尽，《动手学深度学习》也是一本很好的书。他中文版可能还行，我还没看完。 https://zh.d2l.ai/index.html

六、
搞出来手写数字数据集的前馈神经网络模型和卷积神经网络，deep learning就算真的入门了。剩下的世界全靠自己探索，比如去kaggle上面打比赛，比如在google colab上面免费跑模型。

比如我最近就在搞基于财务数据的股票套利模型，看回测都挺好的，也有很强的理论解释性。

如果想系统补足数学方面的知识，《deep learning》花书前几章看完足以，然而这书后面也是劝退级的。  
