# 《高性能MySQL》阅读总结·一
> 之前看了《MySQL必知必会》入了门，但只限于使用sql语句还是远远不够，很有必要入手看下bible级读物--《高性能MySQL》。书很厚，共16章：1-3章是MySQL及其性能优化的基础概念；4、5、6、7章很详细地讲解了如何从schema，索引，查询和MySQL高级特性等几个方面去提高MySQL的性能；之后剩下的一大部分主要是从DBA的角度实现一个高性能MySQL数据库。出于自身知识储备和实用的角度，主要精力先暂时放在前面两部分内容。

## 第一部分 

**MySQL逻辑架构** 

MySQL逻辑架构大致可分为三层：
1. 连接/线程处理。该层用于处理客户端连接，授权处理，安全控制等等，大部分基于网络的客户端/服务器应用都有这一层
2. 解析器--查询缓存--优化器。大部分核心功能（查询解析，分析，优化，缓存，全部内置函数）和跨引擎功能（视图，触发器，存储过程）都位于这一层
3. 存储引擎。存储引擎负责数据的提取和存储。服务器通过api与这些引擎通讯。存储引擎api屏蔽了引擎间的区别，存储引擎本身不解析sql语句，也不相互通信。

![architecture](https://pic002.cnblogs.com/images/2012/152332/2012031510324452.png)

**并发控制** 

MySQL从服务器和存储引擎层面利用锁来进行并非控制。常见的锁策略有表锁和行级锁。
1. 表锁是最基本开销最小的锁策略，是一种读写锁。MySQL服务器通常会使用自己的表锁而忽略引擎提供的锁机制。
2. 行级锁最大程度地支持并发，因此开销也最大。行级锁都是在引擎层面实现的。

**事务** 

事务的acid特性和sql隔离级别（未提交读，提交读，可重复读，可串行化）。
1. 未提交读会脏读（读取到其他事务未提交的数据）
2. 提交读会出现不可重复读（因为其他事务的提交导致两次查询读取到不同数据）
3. 可重复读保证同个事务多次读取的结果都是一样的。但无法保证读取范围数据时出现的幻行问题。这点innodb和myisan引擎使用了多版本并发控制来解决。（innodb通过在每行数据后面加入创建时间和过期时间来实现）
4. 可串行化，最高级别的隔离，强制事务串行执行。
MySQL事务由存储引擎实现。innodb采用两段锁协议，事务执行过程中只有commit和rollback时，锁才会被释放，此时是隐式锁定。innodb还能用特别的语句显式使用锁。

**存储引擎** 
1. innodb：事务型存储引擎，数据存储在表空间，基于聚簇索引建立。提供四个标志的隔离级别，用mvvc支持高并发，默认可重复读。存储格式平台无关，支持热备份。
2. myisan: 提供全文索引，空间索引，压缩，但不支持事务和行级锁
3. memory: 数据保存在内存中，支持hash索引。通常用于1.查找和映射表，2.存储数据处理时的中间数据。MySQL在执行查询过程中通常用memory表作为临时表保存中间结果。

**基准测试指标** 
1. 吞吐量：单位时间（通常是秒）处理的事务数
2. 响应时间or延时：通常使用最大响应时间or响应时间百分比来表示。如最大响应时间是10ms，95%的响应时间都是5ms。
3. 并发性：同时工作的并发操作，如同时工作中的线程or进程。
4. 可扩展性：简单的讲是增加一倍的资源，得到两倍的吞吐量而且性能在可以接受的范围内。通常大部分系统无法做到很理想的线性扩展

**服务器性能定义** 

本书定义为完成某件任务所需的时间度量，即响应时间。
