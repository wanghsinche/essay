# 新版通用前端发布系统搭建
> 组里新的前端发布系统基本开发完成了。新平台在老的发布系统基础上做删减和修改，变成依赖npm的通用前端发布系统，不再局限于某个特定构建工具。本文主要是简单介绍发布平台的技术实现，和开发过程中遇到的一些问题及其解决方案。
## 平台功能介绍
组里目前用的前端构建工具是经过修改的百度fis3，发布系统也只能发布fis3项目的前端工程。因为fis3几乎无人维护，很多新的前端特性都无法使用，没有热替换，无法引入npm包，开发效率比较低下，亟需把项目迁移成webpack工程。

旧的发布平台主要实现了根据项目从对应的gitlab拉取代码，构建前端工程，同步资源文件到测试机或正式cdn，并将发布记录入库的功能。为了修改成通用的前端发布平台，新版系统需要实现的功能点有：

1. 基本的api服务器，用于项目信息查询，用户管理，和权限控制
2. 基于npm的通用前端发布环境和部署模块，供api服务器调用
3. 线上站点版本回退，用于误操作时的紧急恢复

## 技术实现
### 新版发布平台结构示意
 ![示意图](http://nos.netease.com/knowledge/07fe418b-38cd-4f44-952a-6cd7fd34f5dc?imageView&thumbnail=500x0) 
### api服务器部分
api服务器功能基本延续旧版发布系统。考虑到接口参数验证，权限控制和线上监控的问题，新版api服务器用restify框架重写。
由于是内部工具平台，并发量不高，这部分实现起来相对简单。
### 前端项目构建和发布部分
该部分是发布系统的核心功能，旧版本发布系统没有与api服务器解耦，直接在controller里用`child_process`模块调用系统命令完成构建并发布。这种设计有几个缺点：
1. 系统命令的调用都是异步函数，导致发布过程需要处理大量回调函数或者promise，代码不够直观，不利于后续维护更新
2. 每一个系统命令都需要再次封装成js函数，增加了很多不必要的代码，调试很不方便
3. `child_process`模块每次调用外部程序都会新建一个子进程，每次构建发布项目需要运行好几个外部命令，资源浪费严重。

所以，需要重新设计这部分功能。经过讨论，可行的方案有两种：
1. 把api服务器和发布系统分开成两个程序。api服务器提交发布请求到发布系统，发布系统开始构建并部署，并将结果推送给api服务器，由api服务器返回给客户端。
2. 把前端构建和发布过程都写成bash脚本，api服务器用child_process的spawn方法调用脚本，完成构建。 

两种方法各有优缺点：第一种办法实现了解耦，两个程序之间用消息中间件或者rpc相互通信，可以玩出很多很有意思的花样--两部分可以分开开发，也可以部署到不同的服务器，对单元测试也比较友好。但系统比较复杂，工作量增加不少。两个程序之间的通信还需要引入很多额外的东西，对于一个内部工具平台来说，不够划算。 

相比而言，第二种方法更加简单。api服务器直接调用bash脚本完成构建和发布工作，几乎不用处理异步函数，也基本不用担心nodejs大量生成子进程调用外部命令导致的性能问题。但是这种方法也有一些缺点：

1. bash脚本需要传入的参数很多，用环境变量传参的方法比较合理，但这也为后续的构建埋下了陷阱。
2. bash脚本处理字符串功能很弱，sed，egrep等命令并不好用，还需要写额外node脚本为生成的资源文件打标记等等。
3. bash脚本在远端服务器上出错很难调试，而且不好定位问题。

虽然有上述缺点，但方案2还是比较划算的，新版发布系统最终选择了第二种方案。

### 线上版本回退功能
为了防止错误发布上线，线上版本回退是很重要的。新版发布系统延续老平台的做法，每次发布正式时同时备份一份到备份文件夹，由于静态文件都有hash，所以回退时只要替换线上html即可。

### 配置webpack构建环境
组里的项目大多是活动页，webpack的配置基本一致，依赖的库也区别不大。如果每次新建一个项目都重新npm安装一遍，那么安装时间会很久而且浪费大量空间。所以最好是把webpack项目依赖的库和loader都变成公用的，这样新建项目就不用重新npm install了。但是实际使用发现全局安装的webpack loader都不起作用，而且其他全局安装的模块也都无法找到。查文档后发现有几个途径可以处理这个问题：
1. webpack的resolveloader选项可以指定loader所在目录，然而webpack配置文件还依赖其他模块，依旧会出现module not found错误。
2. webpack的运行环境是nodejs，通过配置`NODE_PATH`环境变量指定全局模块的位置，可以把让webpack从全局目录加载loader和其他模块。
3. 对于非核心模块，Node.js 会从当前模块的父目录开始，尝试从它的 /node_modules 目录里加载模块，如果找不到就会查找上一级目录，直到文件系统的根目录。所以如果把webpack项目都放在同一个目录下，并在这个目录安装公用的模块，则目录下的webpack项目都能使用公用的模块。

经过讨论和大量尝试，最后采用了第三个方案。这样可以避免把全部模块都安装到全局，也不用特意修改系统环境变量。

值得一提的是webpack，webpack-dev-server，webpack-cli三件套必须在公用目录和全局目录都安装一遍，否则不能启动webpack开发服务器。

## 值得注意的点
总体的结构和思路都介绍了，值得一提的是用调用bash脚本构建前端工程存在不少陷阱，值得在此提出。

1. `child_process`模块的`spawn`方法可以调用bash脚本，生成子进程。我们可以通过env选项传入子进程运行时的系统变量，并用cwd选项指定运行路径。但是传入env选项，会改写原先的环境变量，需要用`Object.assign`把原有的环境变量也一并传入。
2. bash脚本需要有执行权限，否则无法用`spawn`调用。 
3. `spawn`启动的bash脚本环境变量与直接启动时不同，有时会出现各种意想不到的的结果，需要注意。
4. 资源文件使用`rsync`同步到测试和正式环境。由于html和其他资源文件不是同一个目标路径。需要用 --exclude=* 参数，这导致子目录也被排除在外，因此还需要加入 --include=*/ 。

## 结尾
这次讲的都是发布系统后台的东西。由于这个系统是通用的发布平台，依赖npm完成前端工程的构建，所以基本忽略了特定的前端构建工具的配置问题。
对于一个完整的前端发布平台，构建工具（webpack）配置，前端资源引入方式，cdn地址替换，代码打包，格式检查都是很重要的。后续有时间还需整理介绍一下这方面的内容。
